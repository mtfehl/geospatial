---
title: "Class Session 01"
author: "Michael Fehl"
description: "info about the class 1 materials"
date: 2025-12-19
output: html
    
execute:
  eval: true
  echo: true    
  message: false
  warning: false
  cache: true    
---

Bruno's Office: 20.1E64 (by cafeteria)

```{r r_packages, echo=FALSE}
# set up
rm(list=ls())
libs <- c("tidyverse",            # tidyverse universe
              "sf",               # vectorized spatial data: 'simple features'
              "sp",               # 
              "spData",           # spatial datasets
              "terra",            # 
              "exactextractr",    # 
              "raster",           # 
              "gdistance",        # 
              "data.table",       # high-dimension, fast data computation
              "haven",            # import/save Stata .dta files
              "leaflet")          # interactive dashboards

for (i in libs){
if (!require(i, character.only = TRUE)){
    install.packages(i)
    library(i, character.only = TRUE)
  } else{
    library(i, character.only = TRUE)
  }
}
```

# Intro

## Application Examples

-   Cholera Maps in London
-   Long-term Consequences of Mita (Colonial) System in Peru
    -   Spatial discontinuity to find long-lasting development differences
-   Transport Integration and Welfare in India
-   Climate Change & Urbanization in Africa

## Data Sources

Comprehensive list of spatial data sources:

| Category | Data Sources & Links |
|:-----------------------------------|:-----------------------------------|
| **General & Administrative** | • [Natural Earth](https://www.naturalearthdata.com/downloads/) — Immense GIS database <br> • [CIESIN](https://dataverse.harvard.edu/dataverse/ciesin) — Large GIS database <br> • [DIVA](https://diva-gis.org/data.html) — Country-level data <br> • [GADM](https://gadm.org/data.html) — Administrative boundaries (0-4) <br> • [Geographic names](https://www.geonames.org/) — Locality geocoding <br> • [Long-lat](https://opencagedata.com) — API geocoding |
| **Satellite & Imagery** | • [USGS](https://earthexplorer.usgs.gov/) — Satellite imagery <br> • [Modis](https://modis.gsfc.nasa.gov/) — Satellite imagery <br> • [NOAA VIIRS](https://payneinstitute.mines.edu/eog/nighttime-lights/) — Nighttime lights |
| **Physical & Environment** | • [SRTM](https://srtm.csi.cgiar.org/) — Elevation <br> • [SAGE](https://sage.nelson.wisc.edu/data-and-models/datasets/) — Land cover <br> • [GFC](https://earthenginepartners.appspot.com/science-2013-global-forest) — Forest change <br> • [gROADS](https://search.earthdata.nasa.gov/search/granules?p=C3550192909-ESDIS) — Road networks <br> • [Mineral Resources](https://mrdata.usgs.gov/general/map.html) — Mineral locations |
| **Climate & Water** | • [AQUASTAT](https://www.fao.org/aquastat/en/) — Water-related data <br> • [PS Lab](https://psl.noaa.gov/data/gridded/) — Temp/Precipitation <br> • [SPEI](https://spei.csic.es/) — Drought index |
| **Agri-Economics** | • [FAO-GAEZ](https://gaez.fao.org/) — Farm/Land data <br> • [Harvest Choice](https://www.ifpri.org/program/harvestchoice) — Farm/Land data <br> • [mapSPAM](https://www.spatialproduction.com/) — Farm/Land data |
| **Geocoded Surveys** | • [LSMS](https://www.worldbank.org/en/programs/lsms) — Geocoded surveys <br> • [DHS surveys](https://dhsprogram.com/) — Geocoded surveys |

# Vector Data: `sf`

Reference: --- (2019) "Geocomputation w/ R" Chapters x-y

`sf`: 'Simple Feature'

Spatial Data is stored as **vector** form or **raster** form. We'll focus on the **vector** format first

-   *Vectors*
    -   Spatial geometries: collection of pts/lines/polygons over a geography
    -   Stored as a variable in a df: `st_sf`
    -   Typical formats:
        -   .shp (most common)
        -   .json (geoJSON)
        -   .gpk (geopackage)
        -   .kmz (google earth)

## Basics

We have three basic geometries for our vector data: *points*, *lines*, & *polygons*

These geometries are stored as arrays: numeric vectors, matrices, & lists

### Shapes

#### 1. **Points**

Simplest form of geometry; typically translate to (LONG, LAT)

A single **POINT** is declared using the command `st_point`, by passing in a single numeric vector:

```{r point}
# single point
geom_point <- c(2,4)
single_pt <- st_point(geom_point)
st_as_text(single_pt)
```

whilst a collection of points is known as **MULTIPOINT**, declared using the command `st_multipoint` command, which expects a numeric matrix (*specifically a 2D array*):

```{r multipoints}
# multiple points
geom_multipoints <- rbind(c(2,4), c(1,5), c(0,2), c(1,0))
multipts <- st_multipoint(geom_multipoints)
st_as_text(multipts)
```

#### 2. **Lines**

Lines are simply a collection of points connected sequentially (meaning the ordering of our points matters!)

A single **LINESTRING** can be constructed from a 2D numeric array, the same exact way as a **MULTIPOINT**, only now using the command `st_linestring`:

```{r line}
# single line
geom_multipoints <- rbind(c(2,4), c(1,5), c(0,2), c(1,0))
single_line <- st_linestring(geom_multipoints)
st_as_text(single_line)
```

We can also construct multiple linestrings, known as **MULTILINES** using the command `st_multilinestring`: expects a list of numeric matrices (2D arrays).

```{r multilines}
# multiple lines
geom_multilines <- list(rbind(c(2,4), c(1,5), c(0,2), c(1,0)),
                        rbind(c(0,0), c(1,1), c(2,2), c(3,3)),
                        rbind(c(1,1), c(1,0), c(1,-1)))
multi_lines <- st_multilinestring(geom_multilines)
st_as_text(multi_lines)
```

#### 3. **Polygons**

Finally, we can create shapes by building lines as we did before, but now making sure the first point & last point are the same. Polygons require a list of numeric array(s)

A single **POLYGON** follows the same logic as **MULTILINES**, now with the same coordinates for the first and last points. We use now the command `st_polygon` to build this object:

```{r polygon}
# single line
geom_singlepoly <- list(rbind(c(2,4), c(1,5), c(0,2), c(1,0), c(2,4)))
single_poly <- st_polygon(geom_singlepoly)
st_as_text(single_poly)
```

We can, like before with lines, build & assign multiple **POLYGONS** to a single object, aptly named a **MULTIPOLYGON**. The difference for this is that we must input a list of lists; i.e. a list of single polygons, using the command `st_multipolygon`

```{r multipolygons}
# single line
geom_multipoly <- list(list(rbind(c(3,4), c(3,3), c(5,3), c(5,4), c(3,4))), # rectangle
                        list(rbind(c(1,4), c(1,5), c(2,4), c(1,4)))) # right triangle
multi_poly <- st_multipolygon(geom_multipoly)
st_as_text(multi_poly)
```

### Simple Features (sf)

SIMPLE FEATURE:

-   SF COLUMN (GEOMETRY + PROJECTION) +
-   ATTRIBUTE (DATA FRAME)

## **Example 1**: spatial geometries

```{r basic shape plot, results='hide'}
#| code-fold: true
# multipoint (think: long-lat)
multipt_matrix <- rbind(c(3.2, 4), c( 4, 4.6), c(3.8, 4.4),
                           c(3.5, 3.8), c(3.4, 3.6), c(3.9, 4.5))
gm.multipt <- st_multipoint(multipt_matrix)

# linestring (connecting pts; order matters)
linestring_matrix <- rbind(c(0, 3), c(0,4), c(1,5), c(2,5))
gm.linestr <- st_linestring(linestring_matrix)

# polygon (last pt & first pt must match)
angle <- seq(0, 2*pi, length.out = 100)
circle_coords <- cbind(3.5 + 0.5*cos(angle), 0.5 + 0.5*sin(angle))
polygon_matrix <- list(list(rbind(c(0,0), c(1,0), c(3,2), c(2,4), c(1,4), c(0,0))),
                       list(rbind(circle_coords, circle_coords[1,])))
gm.poly <- st_multipolygon(polygon_matrix)

# create these objects into a column: st_sfc
geom <- st_sfc(gm.multipt, gm.linestr, gm.poly)

# our normal (non-geom) dataframe
mock_data <- data.frame(objects = c('multipt', 'linestr', 'polyg'))

# append our geom data to our data_frame, declare it as a sf object
sf_mockdata <- st_sf(mock_data, geometry = geom)

# plot our shapes!
ggplot() +
  geom_sf(data=sf_mockdata) +
  theme_minimal()

```

### Projections

The world is a 3D object: when we try to project this onto a 2D surface (like a map), it is impossible to not have distortion (proven by Gauss, known as the "Theorema Egregium" -- [reference](https://en.wikipedia.org/wiki/Theorema_Egregium) for a deeper dive into the math).

The basic idea behind the differential geometry is that a (2D) plane has $K=0$ Gaussian curvature, whilst a (3D) sphere w/ radius 'R' has a constant & strictly positive curvature, $K=\frac{1}{R^2}$. There does not exist a function to perfectly map the plane to the sphere (and vice versa); consequentially, every cartographic projection must contain at least some distortion between distances.

![Map Projection Distortion](https://pro.arcgis.com/en/pro-app/latest/help/mapping/properties/GUID-70E253E7-407E-469E-91DA-975B382EA6C9-web.png)

Thus, we need to pay attention to what sort of projection structure our data has. There exists a plethora of ways to project the globe onto a map; what is important is that these projections are both:

-   well-defined, and
-   standardized (agree in their projections)

Otherwise when we try to build our spatial models, we might end up at completely incorrect coordinates. The 'standard' (most common) longitude-latitude used is Geodetic CRS: WGS 84; passed as an argument as `crs = 'EPSG:4326'`. For example:

```{r long-lat example1}
gm.point <- st_point(c(11.3, 44.4)) # c(longitude,latitude)
gmc.point <- st_sfc(gm.point,
                    crs = 'EPSG:4326')
gmc.point; st_as_text(gmc.point)
```

What if we have an array (2D matrix) of multipoints that dont have a projection assigned to them? for example:

```{r long-lat no crs}
df.cities <- data.frame(
  name = c('Bologna', 'London', 'Madrid', 'Paris'),
  temperature = c(31, 21, 29,28),
  language = c('Italian', 'English', 'Spanish', 'French'),
  longitude = c(11.3,-0.1,-3.7,2.3),
  latitude = c(44.4,51.5, 40.4,48.8)
)

sf.cities <- st_as_sf(df.cities,coords = c('longitude', 'latitude'))
sf.cities # missing CRS!
```

Notice the output for CRS: `NA` -- it is important to specify and/or standardize

## **Example 2**: Airports

```{r airport plot, results='hide'}
#| code-fold: true
airports <- st_read("ne_10m_airports/ne_10m_airports.shp")

gmsf.world <- world # empty world map

ggplot() +
  geom_sf(data=gmsf.world) +
  geom_sf(data=airports, aes(color=type)) +
  labs(title = "Airport Types, World") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))
```

### 

```{r}



```

### 

```{r}



```

### 

```{r}



```

### 

```{r}



```

### 

```{r}



```

### 

```{r}



```

### 

```{r}



```

### 

```{r}



```

### Saving our work

```{r}
# # export data as a csv file
# fwrite(x = df.merged,file = 'merged_dataset.csv', sep = '\t')
# 
# ## bonus case: Stata Files
# # symbols in the column names. Replace them with '_':
# setnames(df.merged, gsub('\\.', '_',tolower(names(df.merged))))
# # Exporting it:
# write_dta(data = df.merged, path = 'merged_dataset.dta')

```
